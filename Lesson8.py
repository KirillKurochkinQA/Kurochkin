# Задача 1
# Напиши функцию с именем greet, которая принимает один аргумент — имя человека — и выводит на экран приветствие в формате: Привет, {имя}!.
# Вызови эту функцию с любым именем, чтобы убедиться, что она работает.
def greet(name):
    return f"Привет, {name}!"
print(greet("Кирилл"))

# Задача 2
# Напиши функцию с именем multiply, которая принимает два аргумента — числа a и b — и возвращает их произведение.
# Не используй вывод на экран внутри функции. Вызови функцию с любыми двумя числами и выведи результат снаружи с помощью print().
def multiply(num1, num2):
    return num1 * num2
print(multiply(2, 3))

# Задача 3
# Напиши функцию с именем power, которая принимает два аргумента:
# base (основание степени),
# exponent (показатель степени, по умолчанию равен 2).
# Функция должна возвращать base в степени exponent.
# Проверь работу функции двумя способами:
# Вызвав её с двумя аргументами (например, power(3, 4)),
# Вызвав её только с одним аргументом (например, power(5)), чтобы использовалось значение по умолчанию.
# Выведи оба результата с помощью print().
def power(base, exponent=2):
    return base ** exponent
print(power(3,4))
print(power(5))

# Задача 4
# Напиши функцию с именем apply_twice, которая принимает другую функцию func и значение value в качестве аргументов.
# Функция apply_twice должна вызвать func дважды: сначала с аргументом value, а потом — с результатом первого вызова.
# Верни окончательный результат.
# Протестируй свою функцию, создав простую функцию add_one, которая прибавляет 1 к числу, и передав её в apply_twice вместе с числом 3.
# Выведи результат на экран.
def apply_twice(func, value):
    result = func(value)
    return func(result)
def add_one(num1):
    return num1 + 1
print(apply_twice(add_one, 3))

# Задача 5
# Напиши функцию с именем log_call, которая будет декоратором.
# Этот декоратор должен:
# принимать другую функцию в качестве аргумента,
# возвращать новую функцию-обёртку (wrapper),
# при вызове обёртки сначала выводить на экран: Вызывается {имя_исходной_функции},
# а затем вызывать саму исходную функцию с переданными аргументами и возвращать её результат.
# Протестируй декоратор на простой функции say_hello(), которая не принимает аргументов и возвращает строку "Привет!".
# Используй синтаксис @log_call над определением say_hello.
# Выведи результат вызова say_hello() с помощью print().
def log_call(func):
    def wrapper():
        print(f"Вызывается {func.__name__}")
        return func()
    return wrapper
@log_call
def say_hello():
    return "Привет!"
print(say_hello())

# Задача 6
# Напиши функцию с именем get_initials, которая принимает два аргумента: first_name и last_name.
# Функция должна вернуть инициалы в формате: "F. L.", где F — первая буква имени, а L — первая буква фамилии.
# Пример:
# get_initials("Кирилл", "Иванов") → "К. И."
# Вызови функцию с любыми именем и фамилией и выведи результат через print().
def get_initials(first_name, last_name):
    return f"{first_name[0]}. {last_name[0]}."
print(get_initials("Кирилл", "Курочкин"))

# Задача 7
# Напиши функцию с именем describe_pet, которая принимает два аргумента:
# animal_type (тип животного),
# pet_name (имя питомца),
# и возвращает строку вида: "Это {animal_type} по имени {pet_name}."
# Сделай так, чтобы оба аргумента имели значения по умолчанию:
# animal_type="собака",
# pet_name="Бобик".
# Вызови функцию три раза:
# Без аргументов (чтобы использовались значения по умолчанию),
# Только с pet_name="Мурка",
# С обоими аргументами: animal_type="кошка", pet_name="Луна".
# Выведи все три результата через print().
def describe_pets(animal_type = "собака", pet_name = "Бобик"):
    return f"Это {animal_type} по имени {pet_name}."
print(describe_pets())
print(describe_pets(pet_name = "Мурка"))
print(describe_pets(animal_type = "кошка", pet_name = "Луна"))

# Задача 8
# Напиши функцию с именем safe_divide, которая принимает два аргумента: a и b.
# Функция должна возвращать результат деления a / b, но только если b не равно нулю.
# Если b равно нулю, функция должна возвращать строку: "Ошибка: деление на ноль!".
# Вызови функцию дважды:
# С ненулевым делителем (например, safe_divide(10, 2)),
# С нулевым делителем (safe_divide(5, 0)).
# Выведи оба результата через print().
def safe_divide(a, b):
    return a / b if b != 0 else f"Ошибка: деление на ноль!"
print(safe_divide(10, 2))
print(safe_divide(5, 0))

# Задача 9
# Напиши функцию с именем repeat, которая принимает два аргумента:
# text (строка),
# times (целое число, по умолчанию равно 3).
# Функция должна возвращать строку, в которой text повторяется times раз подряд через пробел.
# Пример:
# repeat("привет", 2) → "привет привет"
# repeat("OK") → "OK OK OK"
# Вызови функцию дважды:
# С двумя аргументами,
# Только с одним аргументом (text).
# Выведи оба результата с помощью print().
def repeat(text, times = 3):
    result = (text + " ") * times
    return f"{result.rstrip()}"
print(repeat(text = "привет", times = 2))
print(repeat(text = "пока"))

# Задача 11
# Напиши функцию с именем format_name, которая принимает три аргумента:
# first_name,
# last_name,
# middle_name (необязательный, по умолчанию — пустая строка).
# Функция должна возвращать полную строку с ФИО, оформленную по правилам:
# Если middle_name указан (не пустой), верни: "Фамилия Имя Отчество" (в таком порядке!).
# Если middle_name не указан (оставлен по умолчанию), верни: "Фамилия Имя".
# Примеры:
# format_name("Кирилл", "Курочкин", "Сергеевич") → "Курочкин Кирилл Сергеевич"
# format_name("Анна", "Петрова") → "Петрова Анна"
# Вызови функцию дважды — с отчеством и без — и выведи оба результата через print().
def format_name(first_name, last_name, middle_name = ""):
    return f"{last_name} {first_name} {middle_name}" if middle_name else f"{last_name} {first_name}"
print(format_name(first_name = "Кирилл", last_name = "Курочкин", middle_name = "Андреевич"))
print(format_name(first_name = "Елена", last_name = "Курочкина"))

# Задача 12
# Напиши функцию с именем make_greeting, которая принимает один обязательный аргумент name
# и один необязательный аргумент greeting со значением по умолчанию "Привет".
# Функция должна возвращать строку в формате:
# "{greeting}, {name}!"
# Протестируй функцию двумя способами:
# Вызови с одним аргументом (name="Анна"), чтобы использовалось приветствие по умолчанию.
# Вызови с двумя аргументами: name="Иван", greeting="Здравствуйте".
# Выведи оба результата через print().
def make_greeting(name, greeting = "Привет"):
    return f"{greeting}, {name}!"
print(make_greeting(name="Анна"))
print(make_greeting(name="Иван", greeting = "Здравствуйте"))

# Задача 13
# Напиши функцию с именем is_even, которая принимает один аргумент — целое число n.
# Функция должна возвращать True, если число чётное, и False, если нечётное.
# Не используй print внутри функции.
# Проверь работу функции, вызвав её с числами 4 и 7, и выведи оба результата через print().
def is_even(num):
    return True if num % 2 == 0 else False # мой код
#   return num % 2 == 0 - код который предложила ИИ, более читаемый
print(is_even(4))
print(is_even(7))

# Задача 14
# Напиши декоратор с именем mark, который:
# принимает функцию,
# возвращает обёртку (wrapper),
# при вызове обёртки выводит строку "--- Начало ---",
# затем вызывает исходную функцию и выводит строку "--- Конец ---" после неё.
# Важно:
# Если исходная функция что-то возвращает, обёртка должна вернуть это значение дальше.
# Декоратор должен работать с функциями, у которых любое количество аргументов (используй *args, **kwargs).
# Протестируй декоратор на функции greet_user(name), которая принимает имя и возвращает "Привет, {name}!".
# Примени декоратор с помощью @mark и вызови greet_user("Кирилл"), выведя результат через print().
def mark(func):
    def wrapper(*args, **kwargs):
        print("--- Начало ---")
        result = func(*args, **kwargs)
        print("--- Конец ---")
        return result
    return wrapper
@mark
def greet_user(name):
    return f"Привет, {name}!"
print(greet_user("Кирилл"))

# Задача 15
# Напиши декоратор с именем bold, который:
# принимает функцию,
# возвращает обёртку (wrapper),
# при вызове обёртки берёт результат исходной функции (предполагается, что это строка),
# оборачивает его в HTML-тег <b>, то есть превращает "привет" в "<b>привет</b>",
# и возвращает эту новую строку.
def bold(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return f"<b>{result}</b>"
    return wrapper
@bold
def greet(name):
    return f"Привет, {name}!"
print(greet("Кирилл"))

# Задача 16
# Напиши декоратор с именем upper, который:
# принимает функцию,
# возвращает обёртку (wrapper),
# при вызове обёртки получает результат исходной функции (предполагается, что это строка),
# преобразует его в верхний регистр с помощью метода .upper(),
# и возвращает полученную строку.
def upper(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        result = result.upper()
        return result
    return wrapper
@upper
def get_message():
    return "все хорошо"
print(get_message())

# Задача 17
# Напиши декоратор с именем check_positive, который предназначен только для функций без аргументов, возвращающих число.
# Декоратор должен:
# вызвать функцию,
# получить её результат,
# если результат больше 0, вернуть его как есть,
# если меньше или равен 0, вернуть строку "Ошибка: результат не положительный".
def check_positive(func):
    def wrapper():
        result = func()
        result_new = result if result > 0 else "Ошибка: результат не положительный"
        return result_new
    return wrapper
@check_positive
def get_value():
    return -5
print(get_value())

# Задача 18
# Напиши декоратор с именем add_prefix, который:
# принимает один аргумент — строку prefix (например, "Важно: "),
# возвращает декоратор, который:
# принимает функцию,
# возвращает обёртку (wrapper),
# обёртка принимает любые аргументы (*args, **kwargs),
# вызывает функцию, получает её результат (строку),
# добавляет к результату заданный prefix спереди,
# и возвращает новую строку.
def add_prefix(prefix):
    def inner_decorator(func):
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            return prefix + result
        return wrapper
    return inner_decorator
@add_prefix("Важно: ")
def alert(message):
    return message
print(alert("Сервер недоступен"))
# !!! Справился только с помощью ИИ

# Задача 19
# Напиши декоратор без параметров с именем add_brackets, который:
# принимает функцию,
# возвращает обёртку (wrapper),
# обёртка принимает любые аргументы (*args, **kwargs),
# вызывает функцию, получает её результат (предполагается, что это строка),
# оборачивает результат в квадратные скобки: "[результат]",
# и возвращает эту новую строку.
def add_brackets(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        new_result = f"[{result}]"
        return new_result
    return wrapper
@add_brackets
def get_tage(error_name):
    return error_name
print(get_tage("warning"))

# Задача 20
# Напиши функцию с именем join_with_comma, которая:
# принимает любое количество строк в качестве аргументов (используй *args),
# соединяет их через запятую и пробел,
# и возвращает получившуюся строку.
# Примеры:
# join_with_comma("яблоки") → "яблоки"
# join_with_comma("яблоки", "бананы", "апельсины") → "яблоки, бананы, апельсины"
# Вызови функцию с тремя разными словами и выведи результат через print().
def join_with_comma(*args):
    return ", ".join(args)
print(join_with_comma("яблоки"))
print(join_with_comma("яблоки", "бананы", "апельсины"))

# Задача 21
# Напиши функцию с именем create_email, которая:
# принимает два обязательных аргумента: name и domain,
# и один необязательный аргумент separator со значением по умолчанию ".",
# возвращает строку вида: {name}{separator}@{domain}.
def create_email(name, domain, separator = "."):
    return f"{name}{separator}@{domain}"
print(create_email("kirill", "gmail.com"))
print(create_email("kirill", "gmail.com", separator = "_"))

# Задача 22
# Напиши функцию с именем full_name, которая:
# принимает три аргумента: first, last, middle
# но только first и last — обязательные,
# а middle — необязательный, со значением по умолчанию None,
# функция должна возвращать строку в формате:
# если middle задан (не None) → "Фамилия Имя Отчество"
# если middle не задан → "Фамилия Имя"
def full_name(first, last, middle = None):
    return f"{last} {first} {middle}" if middle is not None else f"{last} {first}"
print(full_name("Кирилл", "Курочкин", "Андреевич"))
print(full_name("Елена", "Курочкина"))

# Задача 23
# Напиши функцию с именем greet_user, которая:
# принимает один обязательный аргумент — name,
# и один необязательный аргумент — time_of_day со значением по умолчанию "день",
# Функция должна возвращать строку:
# "Добрый {time_of_day}, {name}!"
def greet_user(name, time_of_day = "день"):
    return f"Добрый {time_of_day}, {name}!"
print(greet_user("Кирилл", "вечер"))
print(greet_user("Анна"))

# Задача 24
# Напиши функцию с именем get_square_info, которая:
# принимает один аргумент — число side (длина стороны квадрата),
# возвращает сразу два значения:
# периметр квадрата (4 * side),
# площадь квадрата (side * side).
# После определения функции:
# вызови её с числом 5,
# сохрани возвращённые значения в две переменные: p и s,
# выведи их через print() в формате:
# "Периметр: {p}, Площадь: {s}".
def get_square_info(side):
    perimeter = 4 * side
    area = side ** 2
    return perimeter, area
result = get_square_info(5)
p = result[0]
s = result[1]
print(f"Периметр: {p}, Площадь: {s}")

# Задача 25
# Напиши функцию с именем has_even, которая:
# принимает любое количество целых чисел (используй *args),
# возвращает True, если среди них есть хотя бы одно чётное число,
# и возвращает False, если все числа нечётные.
# Протестируй функцию на двух примерах:
# has_even(1, 3, 5) → должно быть False
# has_even(1, 2, 3) → должно быть True
# Выведи оба результата через print().
def has_even(*args):
    for num in args:
        if num % 2 == 0:
            return True
    return False
result_1 = has_even(1, 3, 5)
result_2 = has_even(1, 2, 3)
print(result_1)
print(result_2)

# Задача 26
# Напиши функцию с именем combine_names, которая:
# принимает любое количество строк через *args,
# игнорирует пустые строки (то есть "" или строки с одними пробелами — " "),
# удаляет лишние пробелы в начале и конце у каждой непустой строки (используй .strip()),
# соединяет оставшиеся строки через пробел,
# и возвращает результат.
# Если все строки пустые или пробельные, функция должна вернуть пустую строку.
# Вызови функцию с разными примерами и выведи результаты через print().
def combine_names(*args):
    parts = []
    for part in args:
        stripped = part.strip()
        if stripped:
            parts.append(stripped)
    return " ".join(parts)
print(combine_names(" Кирилл ", " ", " Курочкин "))
print(combine_names("", "   ", ""))
print(combine_names("привет"))

# Задача 27
# Напиши функцию с именем make_acronym, которая:
# принимает любое количество строк через *args,
# игнорирует пустые или пробельные строки,
# из каждой непустой строки берёт первую букву (после удаления пробелов в начале/конце),
# собирает из этих букв аббревиатуру в верхнем регистре,
# и возвращает её.
# Если нет ни одной непустой строки, функция должна вернуть пустую строку.
# Вызови функцию с разными примерами и выведи результаты через print().
def make_acronym(*args):
    parts = []
    for part in args:
        stripped = part.strip()
        if stripped:
            parts.append(stripped[0].upper())
    return "".join(parts)
print(make_acronym("Кирилл", " Курочкин "))
print(make_acronym("Hello", " world ", ""))

# Задача 28
# Напиши функцию с именем filter_positive, которая:
# принимает любое количество чисел через *args,
# возвращает список только тех чисел, которые строго больше нуля.
# Не используй внутри функции print — только return.
# После определения функции вызови её с примером и выведи результат через print().
def filter_positive(*args):
    parts = []
    for part in args:
        if part > 0:
            parts.append(part)
    return parts
print(filter_positive(1, -2, 3, 0, -5))

# Задача 29
# Напиши функцию с именем get_initials, которая:
# принимает любое количество строк через *args,
# игнорирует пустые или пробельные строки,
# из каждой непустой строки берёт первую букву в верхнем регистре,
# и возвращает строку из этих букв без пробелов.
# Вызови функцию с разными примерами и выведи результаты через print().
def get_initials(*args):
    initials = []
    for part in args:
        stripped = part.strip()
        if stripped:
            initials.append(stripped[0].upper())
    return "".join(initials)
print(get_initials("Кирилл", " Курочкин ", " Андреевич "))

# Задача 30
# Напиши функцию с именем sum_positive, которая:
# принимает любое количество чисел через *args,
# суммирует только те, которые строго больше нуля,
# и возвращает сумму.
# Если нет ни одного положительного числа, функция должна вернуть 0.
# Вызови функцию с примером и выведи результат через print().
def sum_positive(*args):
    parts = 0
    for part in args:
        if part > 0:
            parts += part
    return parts
print(sum_positive(1, -2, 3, 0, 4))
print(sum_positive(-1, -5, 0))